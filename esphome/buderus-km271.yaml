### Update km271_params.h 2023-04-14
### RS232 Serielle Schnittstelle mit 2400 baud UART über GPIOs (TX-pin: GPIO1 # TXD RX-pin: GPIO3 # RXD)
### LED-Output: GREEN-LED (Wifi) an pin GPIO21 # IO21 und RED-LED (Recieve Data) an pin GPIO25 # IO2
### 2023-05-05 Update ESP-Version 2023.4.4
### 2023-05-29 Update ESP-Version 2023.5.5, added alternative WLAN-2 SSID
### 2023-10-22 Changed path: /config/esphome/my_components
### 2024-04-19 Added WiFi Status
### 2024-06-29 Update OTA for ESPhome V6
### 2024-10-01 Added BlueTooth esp32_ble_tracker and bluetooth_proxy
### 2024-11-17 Removed BlueTooth esp32_ble_tracker and bluetooth_proxy
### 2024-11-24 Added Comment, Project Information and id names
### 2024-11-30 Changed WiFI LED to monochromatic LED
### 2024-12-01 Removed RED and GREEN LED IOs (not connected) and changed RX to BLUE Onboard-LED
### 2025-01-18 Changed BUTTON commands to send via 3964R communication
### 2025-01-31 Remove WLAN Fallback Password and enable ESP32 Bluetooth LE to Provide Wifi Credential
### 2025-02-12 Deactivated Web-Server
### 2025-03-05 Removed custom component (as not supported by ESPHome 2025 anymore)
### 2025-03-09 Changes WIFI Fallback Password
### 2025-03-16 Added HK1 Raumisttemperatur (Message A11F)
### 2025-08-31 Adde switch safe_mode
### 2025-11-21 Removed include of uart_read_line_sensor
### 2025-11-21 Change to inlude external compunents from Github
###
esphome:
  name: buderus-km271
  comment: "ESP32 Buderus Ecomatic 4000 KM2.0 RS232 Interface 3964R"
  project:
    name: "ESP32.Buderus Ecomatic 4000"
    version: "2024.11.24"
#  includes:
#    - uart_read_line_sensor.h
 
  # Beim Booten wird geprüft, ob die gespeicherten Datumswerte schon vergangen sind.

  on_boot:
    priority: -10
    then:
      - lambda: |-
          // Code erwartet Datumsformat: "TT:MM:YY" (Länge 8, z.B. "01:07:22")
          auto parse_date = [](const std::string &date_str) -> std::tuple<int, int, int> {
            int day = std::stoi(date_str.substr(0, 2));
            int month = std::stoi(date_str.substr(3, 2));
            // Zwei Ziffern: Wir rechnen damit, dass das Datum post-2000 liegt:
            int two_digit_year = std::stoi(date_str.substr(6, 2));
            int year = 2000 + two_digit_year;
            //return std::make_tuple(day, month, two_digit_year);
            return std::make_tuple(day, month, year);
          };

          // Hole den aktuellen Zeitpunkt von der Zeitkomponente
          auto now = id(my_time).now();
          if (!now.is_valid()) {
            ESP_LOGW("init", "Zeit noch nicht synchronisiertspätere Prüfung erfolgt");
            return;
          }

          // Funktion, die das gespeicherte Datum mit der aktuellen Zeit vergleicht.
          // Liegt es in der Vergangenheit, wird es auf das aktuelle Datum aktualisiert.
          auto check_and_update = [&parse_date, now](std::string &date_str, const char* label) {
            int day, month, year;
            std::tie(day, month, year) = parse_date(date_str);
            std::tm stored = {};
            stored.tm_mday = day;
            stored.tm_mon  = month - 1;
            stored.tm_year = year - 1;  // Notwendig für std::mktime()
            std::time_t stored_time = std::mktime(&stored);
            std::time_t current_time = now.timestamp;
            if (stored_time < current_time) {
              char buf[9];  // Format "TT:MM:YY" plus Null-Terminierung
              std::strftime(buf, sizeof(buf), "%d:%m:%y", std::localtime(&current_time));
              date_str = std::string(buf);
              ESP_LOGD("init", "%s wurde aktualisiert auf: %s", label, buf);
            }
          };

          // Überprüfe und aktualisiere die persistierten Datumswerte
          check_and_update( id(ferienanfang_date), "Ferienanfang");
          check_and_update( id(ferienende_date), "Ferienende");



esp32:
  board: esp32dev
  framework:
    #type: arduino
    type: esp-idf

# enabel Web Server Interface
#web_server:
#  port: 80
#  version: 2
#  log: false
#  auth:
#    username: "buderus-km271"
#    password: !secret web_server_password

# Enable logging
logger:
  level: DEBUG   # makes uart stream available in esphome logstream
  baud_rate: 0     # Disable UART logging (pins GPIO1/3 are used for RS232 communication)

# Enable Home Assistant API
api:
  encryption:
    key: "gK09H5EiMD47LhkrQ3ZEG9cM0pNXJQ3QmvHpfG/BR+s="

# Serielle Schnittstelle schreiben
  services:
    - service: write
      variables:
        command: string
      then:
# TX-LED on
        #- output.turn_on: tx_led # RED LED
        - output.turn_on: onboard_led # BLUE LED
# Write Command
        - uart.write:
            id: uart_bus
            data: !lambda |-
              std::string str = command;
              std::vector<uint8_t> vec(str.begin(), str.end());
              return vec;
# TX-LED off
        - delay: 0.25sec
        #- output.turn_off: tx_led # RED LED
        - output.turn_off: onboard_led # BLUE LED

ota:
  platform: esphome
  password: "f4efe32c05640f63c275bc7d7e8cde5e"

wifi:
  networks:
  - ssid: !secret wifi_ssid
    password: !secret wifi_password
  - ssid: !secret wifi_ssid_2
    password: !secret wifi_password_2

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Buderus Fallback Hotspot"
    password: "1234567890" # No Password

# Sets up Bluetooth LE (Only on ESP32) to allow the user
# to provision wifi credentials to the device.
esp32_improv:
  authorizer: none


#### ENABLE BLUETOOTH BLE TRACKER ################################
#esp32_ble_tracker:
#  scan_parameters:
#    interval: 1100ms
#    window: 1100ms
#    active: true

#bluetooth_proxy:
#  active: true


#### LOCAL TIME ##################################################
time:
  - platform: sntp
    id: my_time


captive_portal:

#### EXTERNAL COMPONENTS #########################################
external_components:
  - source: github://GernotAlthammer/buderus_ecomatic4000@main
    components: [km271_wifi]
    refresh: 0s
#  - source:
#      type: local
#      path: /config/esphome/my_components
 
km271_wifi:
  - id: budoil
    uart_id: uart_bus


#### Globale Variablen ###########################################
globals:
  - id: heizzeit_value
    type: uint8_t
    restore_value: yes
    initial_value: '0x00'  # Standard: "Lang" = 0x00

  - id: sommerzeit_auto_value
    type: uint8_t
    restore_value: yes
    initial_value: '0x00'  # Standard: "Ja" = 0x01

  # Persistente Globals für Datumsangaben im Format TT:MM:YY
  - id: ferienanfang_date
    type: std::string
    restore_value: yes
    initial_value: '"01:01:25"'

  - id: ferienende_date
    type: std::string
    restore_value: yes
    initial_value: '"01:01:25"'


#### UART ########################################################
# RS232 Serielle Schnittstelle mit 2400 baud UART über GPIOs (TX-pin: GPIO1 # TXD RX-pin: GPIO3 # RXD)
uart:
  tx_pin: GPIO1 # TXD
  rx_pin: GPIO3 # RXD
  baud_rate: 2400
  id: uart_bus
  debug:
    direction: BOTH
    dummy_receiver: false
    after:
      delimiter: "\n"
    sequence:
      # - lambda: UARTDebug::log_string(direction, bytes);
       - lambda: UARTDebug::log_hex(direction, bytes, ':');
      # - lambda: UARTDebug::log_int(direction, bytes, ',');
      # - lambda: UARTDebug::log_binary(direction, bytes, ';');

#### OUTPUT ######################################################
# LEDs an GPIOs ansteuern
output:
  # GREEN LED
  #- id: wifi_led
  #  #platform: gpio
  #  platform: ledc
  #  pin: GPIO21 # IO21
  # RED LED
  #- id: tx_led
  #  platform: gpio
  #  pin: GPIO25 # IO25

# BLUE Onboard-LED an GPIO2 ansteuern
  # - platform: esp8266_pwm       ## bei ESP8266 
  - platform: ledc               ## bei ESP32 
    id: onboard_led
    pin:
      number: GPIO2              ## bei ESP8266
      #inverted: true             ## bei ESP8266

light:
# - platform: monochromatic
#   name: "WiFi connection LED"
#   id: wifi_connection_led
#   output: wifi_led
 - platform: monochromatic
   name: "Onboard LED"
   output: onboard_led
   id: blue_led

#### INTERVAL ####################################################
#interval:
#  - interval: 60s
#    then:
#      if:
#        condition:
#          wifi.connected:
#        then:
#          - output.turn_on: wifi_led
#        else:
#          - output.turn_off: wifi_led


#### BUTTON ######################################################
button:

################## Ferienzeiten einstellen ECOMATIC 4000 HS4201
- platform: template
  name: "Ferienzeit einstellen"
  id: km271_ferienzeit_einstellen
  on_press:
    then:
      - lambda: |-
          // Funktion zum Parsen eines Datum-Strings im Format "TT:MM:YY"
          auto parse_date = [](const std::string &date_str) -> std::tuple<int, int, int> {
            int tag = std::stoi(date_str.substr(0, 2));
            int monat = std::stoi(date_str.substr(3, 2));
            int two_digit_year = std::stoi(date_str.substr(6, 2));
            int jahr = 2000 + two_digit_year;
            return { tag, monat, jahr };
          };

          int start_tag, start_monat, start_jahr;
          int end_tag, end_monat, end_jahr;
          std::tie(start_tag, start_monat, start_jahr) = parse_date( id(ferienanfang_date) );
          std::tie(end_tag, end_monat, end_jahr) = parse_date( id(ferienende_date) );
          ESP_LOGD("km271-Ferien", "Start: %i.%i.%i Ende: %i.%i.%i", start_tag, start_monat, start_jahr, end_tag, end_monat, end_jahr);
          
          // Hier wird der Jahreswert vor dem übertragen um den Wert 1900 verringert.
          uint8_t jahr_byte = start_jahr - 1900;
          
          uint8_t data[9];
          data[0] = 0x01;
          data[1] = 0xAC;
          data[2] = 0x00;
          data[3] = 0x00;
          data[4] = start_tag;
          data[5] = start_monat;
          data[6] = jahr_byte;
          data[7] = end_tag;
          data[8] = end_monat;
          ESP_LOGD("km271-Ferien Hex", "UART-Befehl gesendet: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X", data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8]);
          budoil->writer.enqueueTelegram(data, 9);


################## Steuertasten Betriebsarten ECOMATIC 4000 HS4201
# Umschaltung auf Tag-Betrieb Manuell
- platform: template
  name: "Tag-Betrieb - Manuell"
  id: km271_betr_t_manuell
  on_press:
    - lambda:
        uint8_t command[] = {0x31, 0x08, 0x01, 0x10, 0x03, 0x2B};
        budoil->writer.enqueueTelegram(command, 8);
#    - uart.write:
#        id: uart_bus
#        data: [0x02]
#    - delay: 200ms
#    - uart.write:
#        id: uart_bus
#        data: [0x31, 0x08, 0x01, 0x10, 0x03, 0x2B]


# Umschaltung auf Tag-Betrieb Automatik
- platform: template
  name: "Tag-Betrieb - Automatik"
  id: km271_betr_t_auto
  on_press:
    - lambda:
        uint8_t command[] = {0x31, 0x08, 0x03, 0x10, 0x03, 0x29};
        budoil->writer.enqueueTelegram(command, 8);
#    - uart.write:
#        id: uart_bus
#        data: [0x02]
#    - delay: 200ms
#    - uart.write:
#        id: uart_bus
#        data: [0x31, 0x08, 0x03, 0x10, 0x03, 0x29]


# Umschaltung auf Nacht-Betrieb Manuell
- platform: template
  name: "Nacht-Betrieb - Manuell"
  id: km271_betr_n_manuell
  on_press:
    - lambda:
        uint8_t command[] = {0x31, 0x08, 0x00, 0x10, 0x03, 0x2A};
        budoil->writer.enqueueTelegram(command, 8);
#    - uart.write:
#        id: uart_bus
#        data: [0x02]
#    - delay: 200ms
#    - uart.write:
#        id: uart_bus
#        data: [0x31, 0x08, 0x00, 0x10, 0x03, 0x2A]


# Umschaltung auf Nacht-Betrieb Automatik
- platform: template
  name: "Nacht-Betrieb - Automatik"
  id: km271_betr_n_auto
  on_press:
    - lambda:
        uint8_t command[] = {0x31, 0x08, 0x02, 0x10, 0x03, 0x28};
        budoil->writer.enqueueTelegram(command, 8);
#    - uart.write:
#        id: uart_bus
#        data: [0x02]
#    - delay: 200ms
#    - uart.write:
#        id: uart_bus
#        data: [0x31, 0x08, 0x02, 0x10, 0x03, 0x28]


##################################################################


# Hier kommen zwei Eingabefelder (text), die über das Dashboard (z. B. in Home Assistant) bearbeitbar sind.
# Beim Ändern von "Ferienanfang" wird der neue Wert gespeichert und gleichzeitig "Ferienende" aktualisiert,
# sofern letzteres sonst einen früheren Zeitpunkt hätte.
text:
  - platform: template
    mode: text
    optimistic: true
    min_length: 8
    max_length: 8
    name: "Ferienanfang"
    id: ferienanfang_picker
    initial_value: "01:07:25"
    on_value:
      then:
        - lambda: |-
            // Den neuen Wert (als String im Format "TT:MM:YY") aus dem Eingabefeld übernehmen
            std::string new_date = x;
            // Global für Ferienanfang aktualisieren
            id(ferienanfang_date) = new_date;
            ESP_LOGD("date", "Ferienanfang gesetzt auf %s", new_date.c_str());
            
            // Funktion zum Parsen eines Datumsstrings "TT:MM:YY" in ein std::tm-Objekt.
            auto parse_date = [](const std::string &date_str) -> std::tm {
              std::tm t = {};
              t.tm_mday  = std::stoi(date_str.substr(0,2));
              t.tm_mon   = std::stoi(date_str.substr(3,2)) - 1;
              // Für tm_year: 2000 wird zu 100 (da tm_year seit 1900 gezählt wird)
              t.tm_year  = std::stoi(date_str.substr(6,2)) + 100;
              return t;
            };

            std::tm start = parse_date(new_date);
            std::tm current_end = parse_date( id(ferienende_date) );
            std::time_t start_time = std::mktime(&start);
            std::time_t end_time = std::mktime(&current_end);
            if (end_time < start_time) {
              // Falls das bisherige Ferienende vor dem neuen Ferienanfang liegt: auch Ferienende anpassen
              id(ferienende_date) = new_date;
              id(ferienende_picker).publish_state(new_date);
              ESP_LOGD("date", "Ferienende automatisch auf %s aktualisiert", new_date.c_str());
            }

  - platform: template
    mode: text
    optimistic: true
    min_length: 8
    max_length: 8
    name: "Ferienende"
    id: ferienende_picker
    initial_value: "01:07:25"
    on_value:
      then:
        - lambda: |-
            std::string new_date = x;
            auto parse_date = [](const std::string &date_str) -> std::tm {
              std::tm t = {};
              t.tm_mday  = std::stoi(date_str.substr(0,2));
              t.tm_mon   = std::stoi(date_str.substr(3,2)) - 1;
              t.tm_year  = std::stoi(date_str.substr(6,2)) + 100;
              return t;
            };

            std::tm start = parse_date( id(ferienanfang_date) );
            std::tm end   = parse_date(new_date);
            std::time_t start_time = std::mktime(&start);
            std::time_t new_end_time = std::mktime(&end);

            // Das Feld "Ferienende" darf nicht früher liegen als "Ferienanfang"
            if (new_end_time < start_time) {
              ESP_LOGW("date", "Das gewählte Ferienende (%s) liegt vor dem Ferienanfang (%s). Änderung wird nicht übernommen.", 
                        new_date.c_str(), id(ferienanfang_date).c_str());
              // Das Eingabefeld Ferienende wieder auf den aktuellen (gültigen) Wert setzen:
              id(ferienende_picker).publish_state( id(ferienanfang_date) );
              id(ferienende_date) = id(ferienanfang_date);
            } else {
              id(ferienende_date) = new_date;
              ESP_LOGD("date", "Ferienende gesetzt auf %s", new_date.c_str());
            }


#### NUMBER ######################################################
number:
# Below is the real example stuff
  - platform: km271_wifi
    config_ww_temp_target:
      name: "Warmwassersolltemperatur Tag"
      id: warmwassersolltemperatur_tag
      mode: box
    config_heating_circuit_1_design_temperature:
      name: "Auslegungstemperatur"
      id: auslegungstemperatur
      mode: box
    config_heating_circuit_1_room_target_temperature_day:
      name: "HK1 Raumsolltemperatur Tag"
      id: heizkreis1_raumsolltemperatur_tag
      mode: box
    config_heating_circuit_1_room_temperature_offset:
      name: "HK1 Raumtemperatur Offset"
      id: heizkreis_1_raumtemperatur_offset
      mode: box
    config_heating_circuit_1_flow_temperature_max:
      name: "HK1 Heizkreistemperaur Maximal"
      id: heizkreis_1_heizkreistemperatur_maximal
      mode: box

#### SELECT ######################################################    
select:
# Below is the real example stuff
  - platform: km271_wifi
    config_heating_circuit_1_operation_mode:
      name: "HK1 Betriebsmodus"
      id: heizkreis_1_betriebsmodus

  - platform: template
    name: "Heizzeiteingabe"
    id: heizzeit_select
    options:
      - "Lang"
      - "Kurz"
    initial_option: "Lang"
    optimistic: true
    set_action:
      - lambda: |-
          if (x == "Lang") {
            id(heizzeit_value) = 0x00;
          } else {
            id(heizzeit_value) = 0x01;
          }
          // Neues UART-Kommando absenden
          //id(sende_uart)();

  - platform: template
    name: "Sommerzeit automatisch"
    id: sommerzeit_auto_select
    options:
      - "Ja"
      - "Nein"
    initial_option: "Ja"
    optimistic: true
    set_action:
      - lambda: |-
          if (x == "Ja") {
            id(sommerzeit_auto_value) = 0x01;
          } else {
            id(sommerzeit_auto_value) = 0x00;
          }
          // Auch hier das Kommando absenden
          //id(sende_uart)(); //


#### BINARY SENSOR ###############################################
binary_sensor:
  - platform: status
    name: "WiFi Status"
    id: buderus_wifi_status

  # Below is the real example stuff
  - platform: km271_wifi
    # Betriebswerte 1 HK1
    heating_circuit_1_automatic:
      name: "HK1 Automatik"
      id: hk1_automatik
      entity_category: ""

    heating_circuit_1_ww_priority_processing:
      name: "HK1 Warmwasservorrang"
      id: hk1_warmwasservorrang
      entity_category: ""

    heating_circuit_1_screed_drying:
      name: "HK1 Estrichtrocknung"
      id: hk1_estrichtrocknung
      entity_category: ""

    heating_circuit_1_holiday:
      name: "HK1 Ferien"
      id: hk1_ferien
      entity_category: ""

    heating_circuit_1_antifreeze:
      name: "HK1 Frostschutz"
      id: hk1_frostschutz
      entity_category: ""

    heating_circuit_1_manually:
      name: "HK1 Manuell"
      id: hk1_manuell
      entity_category: ""

    # Betriebswerte 1 WW
    ww_automatic:
      name: "WW Automatik"
      id: ww_automatik
      entity_category: ""

    ww_disinfection:
      name: "WW Desinfektion"
      id: ww_desinfektion
      entity_category: ""

    ww_reload:
      name: "WW Nachladung"
      id: ww_nachladung
      entity_category: ""

    ww_holiday:
      name: "WW Ferien"
      id: ww_ferien
      entity_category: ""

    # Steuerung HS4201 Brenner und Mischer
    st_hs4201_b0:
      name: "Brenner EIN"
      id: brenner_ein
      entity_category: ""

    st_hs4201_b1:
      name: "Ladepumpe Warmwasser"
      id: ladepumpe_warmwasser
      entity_category: ""

    st_hs4201_b2:
      name: "Zirkulationspumpe Heizkörper"
      id: zirkulationspumpe_heizkorper
      entity_category: ""

    st_hs4201_b3:
      name: "Mischer AUF"
      id: mischer_auf
      entity_category: ""

    st_hs4201_b4:
      name: "Mischer ZU"
      id: mischer_zu
      entity_category: ""

    st_hs4201_b5:
      name: "Brenner AUS"
      id: brenner_aus
      entity_category: ""

    st_hs4201_b6:
      name: "ST-Bit 6 AN"
      id: st_bit_6_an
      entity_category: ""

    st_hs4201_b7:
      name: "Zirkulationspumpe Fußboden"
      id: zirkulationspumpe_fussboden
      entity_category: ""

    # Steuerung HS4201 Tag/Nacht Automatik/Manuell
    betrzu_b0:
      name: "Betrieb Tag"
      id: betrieb_tag
      entity_category: ""

    betrzu_b1:
      name: "Betrieb Automatik"
      id: betrieb_automatik
      entity_category: ""

    betrzu_b2:
      name: "BTR Bit 2 AN"
      id: btr_bit_2_an
      entity_category: ""

    betrzu_b3:
      name: "BTR Bit 3 AN"
      id: btr_bit_3_an
      entity_category: ""

    betrzu_b4:
      name: "BTR Bit 4 AN"
      id: btr_bit_4_an
      entity_category: ""

    betrzu_b5:
      name: "BTR Bit 5 AN"
      id: btr_bit_5_an
      entity_category: ""

    betrzu_b6:
      name: "BTR Bit 6 AN"
      id: btr_bit_6_an
      entity_category: ""

    betrzu_b7:
      name: "BTR Bit 7 AN"
      id: btr_bit_7_an
      entity_category: ""

#### SENSOR ######################################################
sensor:
# Below is the real example stuff
  - platform: km271_wifi
    heating_circuit_1_flow_target_temperature:
      name: "HK1 Vorlaufsolltemperatur"
      id: hk1_vorlaufsolltemperatur
      entity_category: ""

    heating_circuit_1_flow_temperature:
      name: "HK1 Vorlaufisttemperatur"
      id: hk1_vorlaufisttemperatur
      entity_category: ""

    heating_circuit_1_room_target_temperature:
      name: "HK1 Raumsolltemperatur"
      id: hk1_raumsolltemperatur
      entity_category: ""

    heating_circuit_1_room_temperature:
      name: "HK1 Raumisttemperatur"
      id: hk1_raumisttemperatur
      entity_category: ""
      filters: ## Bei ECOMATIC ist die Temperatur der Wert geteilt duch 10
      - multiply: !lambda return 0.1;

    heating_circuit_1_pump_power:
      name: "HK1 Pumpenleistung"
      id: hk1_pumpenleistung
      entity_category: ""

    heating_circuit_1_mixer_position:
      name: "HK1 Mischerstellung"
      id: hk1_mischerstellung
      entity_category: ""

    ww_target_temperature:
      name: "Warmwassersolltemperatur"
      id: warmwassersolltemperatur
      entity_category: ""

    ww_temperature:
      name: "Warmwasseristtemperatur"
      id: warmwasseristtemperatur
      entity_category: ""

    boiler_target_temperature:
      name: "Kesselvorlaufsolltemperatur"
      id: kesselvorlaufsolltemperatur
      entity_category: ""

    boiler_temperature:
      name: "Kesselvorlaufisttemperatur"
      id: kesselvorlaufisttemperatur
      entity_category: ""

    outdoor_temperature:
      name: "Aussentemperatur"
      id: aussentemperatur
      entity_category: ""

    boiler_runtime_1:
      name: "Brennerlaufzeit 1"
      id: brennerlaufzeit_1
      entity_category: ""

    boiler_runtime_2:
      name: "Brennerlaufzeit 2"
      id: brennerlaufzeit_2
      entity_category: ""

    config_ww_temperature:
      name: "Warmwassertemperatur Ziel"
      id: warmwassertemperatur_ziel
      entity_category: ""

  # WiFi Signal als Sensor
  - platform: wifi_signal
    name: "WiFi Strenght"
    id: km271_wifi_strength
    update_interval: 60s
    icon: mdi:wifi
    entity_category: "diagnostic" 
    
  - platform: copy # Reports the WiFi signal strength in %
    source_id: km271_wifi_strength
    name: "WiFi Percent"
    id: buderus_wifi_percent
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"
    entity_category: "diagnostic"

  # Messung der spannungsversorgung des km271-WiFi boards
  - platform: adc
    pin: 36
    unit_of_measurement: "V"
    name: "Power Supply"
    id: buderus_5v_supply
    accuracy_decimals: 2
    update_interval: 5s
    attenuation: 6dB
    filters:
      - multiply: 28.1826
      - throttle_average: 60s
    entity_category: "diagnostic"

  # Messung der internen Temperatur des km271-WiFi boards - NUR ESP32 #####
  - platform: internal_temperature
    name: "Internal Temp"
    id: buderus_internal_temp
    update_interval: 60s

#### SWITCH ######################################################
switch:
  # Neustart des ESP32
  - platform: restart
    name: "ESP32 Restart"
    id: buderus_wifi_restart
  - platform: safe_mode
    name: "Restart (Safe Mode)"
    id: buderus_safe_mode
    
  - platform: template
    name: "KM271 UART RX"
    id: km271_uart_rx
    turn_on_action:
        - uart.write:
            id: uart_bus
            data: !lambda |-
              std::string str = "\x10";
              std::vector<uint8_t> vec(str.begin(), str.end());
              return vec;
        - delay: 1sec
        - switch.turn_off: km271_uart_rx


#### TEXT SENSOR #################################################
text_sensor:
  - platform: km271_wifi
    firmware_version:
      name: "Firmware Steuerung"
      id: firmwareversion_steuerung

  # Template-Text-Sensoren, um die momentan gültigen Datumswerte anzuzeigen (z. B. in einem Dashboard oder am Log)
  - platform: template
    name: "Ferienanfang Datum"
    id: ferienanfang_display
    lambda: |-
      return { id(ferienanfang_date) };
  - platform: template
    name: "Ferienende Datum"
    id: ferienende_display
    lambda: |-
      return { id(ferienende_date) };

#  # RS232 data as Text-Sensor ## Removed as not supported by ESPhome 2025
#  - platform: custom
#    text_sensors:
#      name: "KM271 RS232 Output"
#      id: "km271rs232_txt"
#    lambda: |-
#      auto my_custom_sensor = new UartReadLineSensor(id(uart_bus));
#      App.register_component(my_custom_sensor);
#      return {my_custom_sensor};

  # Local WiFi Info as Text-Sensor
  - platform: wifi_info
    ip_address:
      name: Buderus IP Address
      id: buderus_ip_address
    ssid:
      name: "SSID"
      id: buderus_ssid
    bssid:
      name: "BSSID"
      id: buderus_bssid
    mac_address:
      name: "Mac Address"
      id: buderus_mac
    scan_results:
      name: Scan Result"
      id: buderus_scan
  # ESP Version
  - platform: version
    name: "ESPHome Version"
    id: buderus_esphome_version

#### END ########################################################
